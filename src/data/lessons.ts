import type { Lesson } from '../types/lesson';

export const lessons: Lesson[] = [
  {
    id: 'rust-basics',
    title: 'Введение в Rust',
    status: 'completed',
    description: 'Узнайте, что такое Rust, как установить его и написать свою первую программу "Hello, World!".',
    imageUrl: 'https://images.unsplash.com/photo-1534796636912-3b95b3ab5986?q=80&w=2071&auto=format&fit=crop',
    sections: [
      {
        id: '1-1',
        title: 'Что такое Rust?',
        content: `
          <p>Rust - это язык программирования, который дает возможность каждому создавать надежное и эффективное программное обеспечение.</p>
          <p>Это мультипарадигменный язык системного программирования, ориентированный на безопасность, особенно на безопасную работу с памятью.</p>
        `,
      },
      {
        id: '1-2',
        title: 'Установка',
        content: `
          <p>Для установки Rust используйте <code>rustup</code>, официальный установщик и менеджер версий Rust. Это самый простой и рекомендуемый способ начать работу. <code>rustup</code> управляет установками Rust и позволяет легко переключаться между стабильной, бета- и ночной версиями компилятора.</p>
          <p>В системах Linux и macOS, откройте терминал и выполните следующую команду:</p>
          <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></pre>
          <p>Эта команда загрузит и запустит скрипт, который установит последнюю стабильную версию Rust. Следуйте инструкциям на экране. После установки, убедитесь, что вы добавили Cargo's bin директорию в ваш системный PATH. Обычно это происходит автоматически.</p>
        `,
      },
      {
        id: '1-3',
        title: 'Hello, World!',
        content: `
          <p>Давайте напишем нашу первую программу на Rust. Это стало традицией в программировании — первая программа на новом языке должна выводить "Hello, world!".</p>
          <p>Создайте файл с именем <code>main.rs</code> и добавьте в него следующий код:</p>
          <pre><code>fn main() {
    println!("Hello, world!");
}</code></pre>
          <p>Этот код определяет главную функцию <code>main</code>, которая является точкой входа в любую исполняемую программу на Rust. Макрос <code>println!</code> выводит текст в консоль. Скомпилируйте и запустите его с помощью <code>rustc main.rs && ./main</code>. Вы должны увидеть заветное сообщение в вашем терминале. Поздравляю, вы официально Rust-разработчик!</p>
        `,
      },
    ],
  },
  {
    id: 'variables-and-data-types',
    title: 'Переменные и типы данных',
    status: 'in_progress',
    description: 'Изучите основы работы с переменными, их изменяемостью и базовыми скалярными типами данных в Rust.',
    imageUrl: 'https://images.unsplash.com/photo-1502134249126-9f3755a50d78?q=80&w=2070&auto=format&fit=crop',
    sections: [
      { 
        id: 'variables-mutability', 
        title: 'Переменные и изменяемость',
        content: `
          <p>По умолчанию, переменные в Rust неизменяемы (immutable). Это одна из ключевых особенностей, которая помогает писать безопасный и предсказуемый код. Когда переменная неизменяема, ее значение не может быть изменено после присваивания.</p>
          <pre><code>let x = 5;
println!("The value of x is: {}", x);
x = 6; // Это вызовет ошибку компиляции!
println!("The value of x is: {}", x);</code></pre>
          <p>Однако, вы можете сделать переменные изменяемыми, добавив ключевое слово <code>mut</code> перед именем переменной. Это явно указывает на то, что вы намерены изменять ее значение.</p>
          <pre><code>let mut y = 5;
println!("The value of y is: {}", y);
y = 6; // Все в порядке!
println!("The value of y is: {}", y);</code></pre>
          <p>Использование неизменяемости по умолчанию заставляет вас быть более осознанными в отношении того, какие части вашего кода могут изменять состояние, что способствует лучшей архитектуре.</p>
        `
      },
      {
        id: '2-2',
        title: 'Скалярные типы',
        content: `
          <p>Rust имеет четыре основных скалярных типа: целочисленные (integer), числа с плавающей точкой (floating-point), логические (booleans) и символы (characters). Они представляют собой единичные значения.</p>
          <ul>
            <li><strong>Integers:</strong> Числа без дробной части. Делятся на знаковые (<code>i</code>) и беззнаковые (<code>u</code>), и имеют размеры 8, 16, 32, 64, 128 бит (например, <code>u32</code>, <code>i64</code>). Беззнаковые типы могут хранить только положительные значения.</li>
            <li><strong>Floats:</strong> Числа с дробной частью. В Rust есть два типа: <code>f32</code> и <code>f64</code> (размер по умолчанию). Современные процессоры обрабатывают <code>f64</code> почти так же быстро, как и <code>f32</code>, но с большей точностью.</li>
            <li><strong>Booleans:</strong> Тип <code>bool</code> имеет два возможных значения: <code>true</code> и <code>false</code>.</li>
            <li><strong>Characters:</strong> Тип <code>char</code> — это самый примитивный алфавитный тип. Важно отметить, что <code>char</code> в Rust представляет собой скалярное значение Unicode, а значит, может представлять гораздо больше, чем просто ASCII.</li>
          </ul>
        `,
      },
    ],
  },
  {
    id: 'ownership',
    title: 'Основные концепции: Владение и Заимствование',
    status: 'not_started',
    description: 'Познакомьтесь с самой уникальной особенностью Rust — системой владения, которая гарантирует безопасность памяти.',
    imageUrl: 'https://images.unsplash.com/photo-1528642474498-1af0c17fd8c3?q=80&w=2069&auto=format&fit=crop',
    sections: [
      { id: 'ownership-intro', title: 'Обзор урока', content: '<p>Владение — это самая уникальная и выдающаяся особенность Rust. Она позволяет Rust обеспечивать гарантии безопасности памяти без необходимости в сборщике мусора (GC) или ручного управления памятью. В этом разделе мы разберем три ключевых правила владения, а также концепции заимствования и срезов.</p>' },
      {
        id: '3-1',
        title: 'Владение (Ownership)',
        content: `
          <p>Ключевая особенность Rust, которая гарантирует безопасность памяти без сборщика мусора. У каждого значения есть переменная, которая является его <strong>владельцем</strong>. Может быть только один владелец в каждый момент времени. Когда владелец выходит из области видимости, значение удаляется из памяти.</p>
          <p>Рассмотрим пример:</p>
          <pre><code>{
    let s = String::from("hello"); // s входит в область видимости
    // можно использовать s
} // область видимости s заканчивается, s больше не действительна</code></pre>
          <p>Это просто, но имеет глубокие последствия для того, как мы пишем код. Когда мы присваиваем одну переменную другой, для сложных типов данных, таких как <code>String</code> (который хранится в куче), происходит <strong>перемещение</strong> (move), а не поверхностное копирование.</p>
          <pre><code>let s1 = String::from("hello");
let s2 = s1;
// println!("{}, world!", s1); // Это вызовет ошибку! s1 было перемещено в s2</code></pre>
          <p>После перемещения <code>s1</code> больше не является валидной переменной, чтобы избежать двойного освобождения памяти.</p>
        `
      },
      {
        id: '3-2',
        title: 'Заимствование (Borrowing)',
        content: `
          <p>Что если мы хотим использовать значение, не передавая владение? Для этого существуют <strong>ссылки</strong>. Процесс создания ссылки называется <strong>заимствованием</strong>. Вместо того чтобы передавать значение в функцию, мы можем передать ссылку на него.</p>
          <pre><code>fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize { // s - это ссылка на String
    s.len()
} // Здесь s выходит из области видимости, но так как оно не владеет значением, ничего не происходит.</code></pre>
          <p>Ссылки по умолчанию также неизменяемы. Однако, вы можете создавать и изменяемые ссылки (mutable references) с помощью <code>&mut</code>. Важное правило: в одной области видимости может быть либо одна изменяемая ссылка, либо любое количество неизменяемых ссылок. Это помогает предотвратить гонки данных во время компиляции.</p>
        `
      },
    ],
  },
  {
    id: 'structs-enums',
    title: 'Структуры и Перечисления (Structs & Enums)',
    status: 'not_started',
    description: 'Научитесь создавать собственные сложные типы данных с помощью структур и перечислений.',
    imageUrl: 'https://images.unsplash.com/photo-1516339901601-2e1b62dc0c45?q=80&w=1974&auto=format&fit=crop',
    sections: [
      { 
        id: 'structs-enums-intro', 
        title: 'Обзор структур и перечислений', 
        content: '<p>В этом уроке мы подробно разберем, как создавать и использовать структуры (structs) и перечисления (enums) в Rust. Эти два типа данных являются основными строительными блоками для создания сложных и выразительных типов в ваших программах. Мы также коснемся мощного механизма сопоставления с образцом (pattern matching), который тесно связан с enums.</p>' 
      },
      {
        id: '4-1',
        title: 'Определение и использование Struct',
        content: `
          <p>Структуры похожи на кортежи (tuples), которые мы обсуждали ранее, в том, что они оба содержат несколько связанных значений. Однако, в отличие от кортежей, в структуре вы даете имя каждому элементу данных, поэтому становится ясно, что означают эти значения. Именовать поля гораздо гибче, чем использовать индексы, как в кортежах.</p>
          <p>Для определения структуры используется ключевое слово <code>struct</code> и имя структуры. Внутри фигурных скобок мы определяем имена и типы полей.</p>
          <pre><code>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};</code></pre>
          <p>Чтобы получить доступ к значению в структуре, мы используем точечную нотацию. Например, чтобы получить доступ к электронной почте пользователя, мы бы написали <code>user1.email</code>.</p>
        `
      },
      {
        id: '4-2',
        title: 'Enums и сопоставление с образцом (Pattern Matching)',
        content: `
          <p>Перечисления (Enums) позволяют определить тип, который может быть одним из нескольких вариантов. Представьте, что нам нужно работать с IP-адресами. Они могут быть либо версии 4, либо версии 6. Enum для этого выглядит идеально:</p>
          <pre><code>enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;</code></pre>
          <p>Прелесть enums в том, что мы можем также хранить данные внутри каждого варианта. Это делает их намного мощнее, чем enums в других языках.</p>
          <pre><code>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));</code></pre>
          <p>Для работы с enums в Rust есть чрезвычайно мощный оператор <code>match</code>, который позволяет выполнять сопоставление с образцом. Он похож на <code>switch</code> в других языках, но с суперспособностями. Он гарантирует, что вы обработали все возможные варианты, что делает ваш код надежнее.</p>
        `
      },
    ],
  },
  {
    id: 'error-handling',
    title: 'Обработка ошибок в Rust',
    status: 'not_started',
    description: 'Изучите, как в Rust обрабатываются ошибки с помощью `Result<T, E>` для написания надежного кода.',
    imageUrl: 'https://images.unsplash.com/photo-1451187580459-43490279c0fa?q=80&w=2072&auto=format&fit=crop',
    sections: [
      { id: 'errors-intro', title: 'Введение в обработку ошибок' },
      {
        id: '5-1',
        title: 'Непаникующие ошибки с Result<T, E>',
        content: '<p><code>Result</code> - это перечисление с вариантами <code>Ok</code> и <code>Err</code>. Это основной способ обработки ошибок в Rust.</p>',
      },
    ],
  },
]; 